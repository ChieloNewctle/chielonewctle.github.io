{"pages":[{"title":"","text":"","link":"/categories/index.html"},{"title":"技巧","text":"很多遇到的问题、技巧、奇奇怪怪的数学性质、结论等都记录在这里。 Coding 相关 数论 (or 数字) GCD 二进制运算 图论 树 二分图 网络流 无向图 Coding 相关# 时常遭受 Runtime Error？或者时常会写一些奇奇怪怪的小错误？来让编译器帮你看看： Catching silly mistakes with GCC - Codeforces Program Instrumentation Options - GCC -Wall -Wextra -Wshadow -Wconversion -Wfloat-equal -Wlogical-op -Wformat=2 -Wshift-overflow=2 -pedantic -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -D_FORTIFY_SOURCE=2 -fsanitize=address -fsanitize=undefined -fno-sanitize-recover=all -fno-sanitize-recover=all 用来保证对拍过程中，遇到 sanity 问题时，就直接带着 error code 结束。 可以把这些写成 bashrc 的一个函数：12345678ccc() { g++ -std=c++17 -Wall -Wextra -Wshadow -Wconversion \\ -Wfloat-equal -Wlogical-op -Wformat=2 -Wshift-overflow=2 \\ -pedantic -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC \\ -D_FORTIFY_SOURCE=2 -fsanitize=address \\ -fsanitize=undefined -fno-sanitize-recover=all \\ -g &quot;$@&quot; -o ${1/\\.cpp/}} 数论 (or 数字)#GCD# 前缀GCD 只有 \\(\\mathcal{O}(\\log{a})\\) 种取值，并单调不严格递减，呈块状 HDU 5726 二进制运算# 前缀AND 只有 \\(\\mathcal{O}(\\log{a})\\) 种取值（考虑每一位的情况），并单调不增，呈块状，值小于或等于 前缀最小值前缀OR 只有 \\(\\mathcal{O}(\\log{a})\\) 种取值，并单调不减，呈块状，值大于或等于 前缀最大值 BCPC2017 决赛 I. 夜晚的街区 图论#树# 树的邻接矩阵（对称阵、无自环）的秩等于树的最大匹配数 Codeforce 1067E 二分图# 二分图的最大匹配数等于最小点覆盖数（可构造），二分图的最大独立集可由点集与最小点覆盖的差集构造 BCPC2017 预赛 E. 气球派对 二分图的题目除了可以藏在树、网格图中以外，某一位异或为一时才有边、和为大于 2 的质数等很多奇奇怪怪的无奇环的性质都可能是。 网络流# 平面图最小割（最大流）等价于对偶图中的最短路 BZOJ 1001 无向图# 走重复点、边的回路可抽取为若干个简单环 按顺序处理点，重复出现点就可以把这一段简单环单独抽出来，重复这样抽取就可以把回路抽取为若干个简单环","link":"/cheat-sheet/index.html"},{"title":"当前赛季比赛列表","text":"const base_url = 'https://icpc.baylor.edu/cm5-contest-rest/rest/contest/public/'; const finder_base_url = 'https://icpc.baylor.edu/regionals/finder/'; const regions = [ 'AR-Nannjing-2019', 'Shanghai-2019', 'Hong-Kong-City-2019', 'Asia-Nanchang-2019', 'Yinchuan-2019', 'Shenyang-2019', 'Xuzhou-2019', 'Asia-EC-League-Final-2019', ]; var contests = []; function safeDate(d) { if(d === undefined) { return 'to be determined'; } return d; } function generateTable() { if(contests.length != regions.length) { return; } contests.sort((a, b) => { return a.startDate == b.startDate ? 0 : a.startDate === undefined || a.startDate > b.startDate ? 1 : -1; }); let table = 'NameStart DateEnd Date'; for(let i in contests) { let contest = contests[i]; let line = ''; line += '' + contest.name + ''; line += '' + safeDate(contest.startDate) + ''; line += '' + safeDate(contest.endDate) + ''; line += ''; table += line; } table += ''; $('#contest-list').html(table); } async function getContest(name) { $.get(base_url + name, (data) => { data.url_name = name; contests.push(data); generateTable(); }); } regions.map(getContest);","link":"/regional-contests/index.html"},{"title":"","text":"","link":"/tags/index.html"}],"posts":[{"title":"Codeforces Round #556 (Div. 1)","text":"题目 A B C D E 状况 AC+0 AC+1 已补 待补 没看 涨分了，终于有点橙汁的颜色了。（我好菜呀） A. Prefix Sum Primes B. Three Religions C. Tree Generator™ D. Abandoning Roads E. Election Promises A. Prefix Sum Primes#题意#\\(a\\) 个 1，\\(b\\) 个 2，用这些构造一个数列 \\(\\{a_i\\}\\)，使得它的前缀和 \\(\\{S_i\\}\\) 出现尽可能多的质数。 题解#质数最多只能让小于或等于 \\(a + 2b\\) 的全部出现一遍；\\(a = 0\\) 或者 \\(b = 0\\) 就直接输出就好，\\(a = 0\\) 时最多能出现个质数 \\(2\\)；如果能有一个 1 和一个 2，那就可以先放下一个 2，再放下一个 1，接下来把剩下的 2 全部放下，最后放下剩下的 1，这样做是因为偶质数只有个 2，接下来尽可能地构造出来所有的奇数，就可以保证小于或等于 \\(a + 2b\\) 的全部出现一遍了。 B. Three Religions# RE 一发，交题的时候没仔细检查，状态压成整数时越界了 题意#给个长度为 \\(n \\le {10}^5\\) 的小写字母字符串 \\(S\\)，然后有 3 个长度不超过 \\(250\\) 初始为空的小字符串 \\(t_{i}\\)。有 \\(q\\) 次操作，要么在某个小字符串后面加一个小写字母，要么删掉某个小字符串最后的字符。每次操作完成后，回答可否从 \\(S\\) 抽取 3 个不相交的子序列，和 3 个小字符串相同。 题解#假设 3 个小字符串不变，可以有 \\({dp}_{i, j, k}\\)，意义是从 \\(S\\) 一个字符一个字符地划分 3 个子序列，构成了 3 个小字符串各自的前 \\(i, j, k\\) 个字符的情况下，最少需要使用到 \\(S\\) 的前 \\({dp}_{i, j, k}\\) 个字符。 有 \\({dp}_{0, 0, 0} = 0\\)，记 \\({nearest}(i, c)\\) 为 \\(S\\) 从第 \\(i\\) 个字符找，字符 \\(c\\) 第一次出现的位置。则：\\[{dp}_{i, j, k} = \\min\\begin{cases}{nearest}({dp}_{i - 1, j, k} + 1, t_{0, i}), &amp; i &gt; 0; \\\\{nearest}({dp}_{i, j - 1, k} + 1, t_{1, j}), &amp; j &gt; 0; \\\\{nearest}({dp}_{i, j, k - 1} + 1, t_{2, k}), &amp; k &gt; 0.\\end{cases}\\] \\(nearest\\) 可以 \\(\\mathcal{O}(n \\Sigma)\\) 时间内预处理出来，\\(dp\\) 转移 \\(\\mathcal{O}(1)\\) 会发现这个 \\(dp\\)，在每次修改某个小字符串，比如 \\(t_0\\) 末尾的时候，只需要重新对各种 \\(j, k\\) 算 \\({dp}(|t_0|, j, k)\\) 即可。 所以时间复杂度大概是 \\(\\mathcal{O}(n \\Sigma + q \\cdot 250 \\cdot 250)\\)。 C. Tree Generator™#比赛时实际想到、也查到了，使用DFS序类似的动态维护树的深度等信息。但是没有想到维护直径的方式（有点菜）。补一下。 D. Abandoning Roads#待补 E. Election Promises#待补","link":"/2019/04/29/Codeforces-Round-556-Div-1/"},{"title":"北航春训 DOMjudge 配置坑点","text":"DOMjudge 版本：6.0.3 总体上来讲，按照官方的 admin manual 一步一步来不会出错的。出现问题时，可以先查手册，然后去查 maillist。 推荐使用最新的（18.10） Ubuntu Server。 测试用题目包#ChieloNewctle/domjudge-contest-sample domserver#部署#没什么好说的，按官方说明的一步一步走即可。 新版本中，在 Jury interface 提供了 Config Checker，可以检查很多配置是否合理，包括一部分的 Finetune 参数。 数据导入导出#源码在 domserver/lib/lib.impexp.php 中。 导入 teams.tsv#先导入 teams.tsv 再导入 accounts.tsv teams.tsv 格式#12File_Version 1唯一的队伍ID\\t 唯一的外部ID\\t team_category的ID\\t 队名\\t 校名\\t 校名（短）\\t 国家\\t 唯一的校名外部ID teams.tsv 样例#12File_Version 11391 springA1391 3 name Beihang University BUAA CHN BUAA 导入 accounts.tsv#accounts.tsv 导入的时候也会自动去挂队伍ID，但方式是跳过 username 前面的非数字字符、再跳过 0 以后，以剩下的数字字符作为对应的队伍ID（剩下的不是数字就不挂队伍了）。对应的源码：1$teamid = preg_replace(&apos;/^[^0-9]*0*([0-9]+)$/&apos;, &apos;\\1&apos;, $line[2]); accounts.tsv 格式#12File_Version 1角色（team, admin等）\\t 名字\\t username\\t password accounts.tsv 样例#12File_Version 1team Chielo chielo P@ssw0rd judgehost#部署#在 admin manual 中的 Quick installation 介绍了大致的流程 On the judgehosts: useradd -d /nonexistent -U -M -s /bin/false domjudge-run Add to /etc/sudoers.d/ or append to /etc/sudoers the sudoers configuration as in etc/sudoers-domjudge. （推荐前者） Set up cgroup support: enable kernel parameters in /etc/default/grub and reboot, then use misc/create_cgroups to create cgroups for DOMjudge. Put the right credentials in the file etc/restapi.secret on all judgehosts (copied from the domserver). （正常来讲，build 好后 install 不会需要这一步） Start the judge daemon: bin/judgedaemon （推荐用 screen 单独跑） 但这只是简单的介绍，具体的还是需要根据 admin manual 后文一步一步来。 cgroups#“enable kernel parameters in /etc/default/grub and reboot” 需要参考节 “Linux Control Groups” 修改后运行 update-grub，否则只修改 /etc/default/grub 重启也不会起效。 运行 judgehost 前记得运行 create_cgroups，建立 cgroups。 单机多 judgehosts#比如我想用 judgehost/bin/judgedaemon -n 2 在主机上运行第二个评测机，则需要运行一次 useradd -d /nonexistent -U -M -s /bin/false domjudge-run-2 建立用户。 运行机制#在搭建好的 domjudge 的 jury interface 中，会有 Languages 和 Executables 的配置。这些决定了哪些语言可以交，长什么样，怎么测。 Time factor#实际是 Time limitation factor，即原题面的时限乘这个因子作为该语言的时限。比如可以给 Java 配置两倍的 Time factor，这样 1 秒钟时限的题目，使用 Java 提交的话时限会放宽到 2 秒钟。 Compile script#这个脚本负责编译参赛者提交的程序。可以是一个 shell 脚本。第一个参数表示要求最终生成的，有 executable 权限的文件路径。 比如 C++，就可以直接把二进制文件生成到目标路径上；Java，就需要生成一个有 executable 权限的脚本，调用 java 去运行。 编译时是在 judgedaemon 运行的环境中进行的，以 domjudge-run 用户运行的。 chroot#Compile script 编译后，运行编译得到的文件时，是将之前建立好的 chroot 环境中的若干目录，挂载到 judgehost/judgings/主机名/endpoint-default/提交id/ 相应的目录中运行的。 因此在更新主机的环境后，chroot 相应的环境也应当进行更新，同步版本。 若有多台评测机时，注意同步运行环境。 kotlin#推荐使用 JetBrains 官方 Github 中的 Release。 在 judgehost 的主机中，配置到让各个用户都可以调用 kotlinc，便可以编译 Kotlin 程序。 在 judgehost 的 chroot 环境中，将 lib 的内容解压到 chroot 中的 lib，bin 的内容解压到 chroot 中的 bin，将 chroot/bin 中的 kotlin 等链接到 chroot/usr/bin 中，这样编译得到的 Kotlin 程序就可以在 judgehost 的 chroot 环境中运行了。","link":"/2019/04/27/DOMjudge-buaa-spring/"},{"title":"2017-2018 Petrozavodsk Winter Training Camp, Saratov SU Contest J.Subsequence Sum Queries","text":"手生的很。 不过这次实际是我偷懒，正解想到了，不敢写。 题意#求一个数组区间内，满足和是 \\(m\\) 倍数的子序列的数量，模 \\({10}^9 + 7\\)。 思路# \\(m\\) 不大，一个区间内所有子序列的和对 \\(m\\) 取模所有情况的数量可以放在一个向量 \\(\\mathbf{v}\\) 里（这里注意“空序列”也被认作答案） 可以离线 区间固定后，内部的序和所需要的信息无关 \\(a_i\\) 的值可直接对 \\(m\\) 取模 可以把在一个区间增加一个 \\(a_i\\) 的操作，转为把已知信息的向量 \\(\\mathbf{v}\\) 乘一个矩阵 你发现你想多了 一个区间增加一个值可以 \\(\\mathcal{O}(m)\\) 修改 两个区间的信息可以 \\(\\mathcal{O}(m^2)\\) 合并，但是只需要模 \\(m\\) 为 \\(0\\) 的信息则可以 \\(\\mathcal{O}(m)\\) 时间内获取 弯路（可略过）#于是可以有很多种做法，比如线段树维护这些信息。甚至可以用离线+并查集： 将询问离线，以右端点升序排序。\\(a_i\\) 按 \\(i\\) 升序往并查集里面插入。并查集保持父亲的标号大于当前点，每个点存下标从自己到父亲之间的信息。路径压缩即两个相邻的区间进行合并；集合合并即增加了一个 \\(a_i\\)，\\(i\\) 节点向 \\(i + 1\\) 合并，并在 \\(i\\) 节点保存区间的信息。 复杂度应该是 \\(\\mathcal{O}\\left(\\left(n + q\\right) m^2 \\alpha\\left(n\\right)\\right)\\)，超时了。 题解#正解：离线+分治。 对区间 \\([1, n]\\) 进行分治，设当前处理到区间 \\([l, r)\\)，询问存储在集合 \\(S\\) 中，记 \\(mid = \\frac{l + r}{2}\\)。 若询问为空，不用处理。若 \\(r - l \\le 1\\)，说明询问区间的长度都为 \\(1\\)，很容易处理（答案不要漏算空序列的情况）。 将询问分为“右端点小于 \\(mid\\)”、“左端点大于或等于 \\(mid\\)”、“其它”三个部分。第一个部分可以分治给 \\([l, mid)\\) 处理，第二个部分可以分治给 \\([mid, r)\\) 处理。其它情况，说明询问的两个端点跨过了 \\(mid\\)。 那么对于询问区间 \\([u, v]\\) 的信息，可以分为 \\([u, mid), [mid, v]\\) 两部分。因为 \\(mid\\) 当前是固定的，考虑从 \\(mid\\) 向 \\(l\\) 维护后缀的信息，从 \\(mid\\) 向 \\(r\\) 维护前缀的信息，这些信息可以如思路中说的 \\(\\mathcal{O}\\left(m * \\left(r - l\\right)\\right)\\) 维护。对于每个询问，由于只需要模 \\(m\\) 为 \\(0\\) 的信息，可以在 \\(\\mathcal{O}(m)\\) 的时间内得到解。 总时间复杂度 \\(\\mathcal{O(n m \\log{n} + q \\log{n} + q m)}\\)。 代码# 超时的并查集 稳健的分治","link":"/2018/06/28/Subsequence-Sum-Queries/"},{"title":"The 16th Zhejiang Provincial Collegiate Programming Contest","text":"队伍训练，个人做了 G, F, H, C, D，都是不难写的，还是菜…… G - Lucky 7 in the Pocket F - Abbreviation H - Singing Everywhere C - Array in the Pocket D - Traveler G - Lucky 7 in the Pocket#签到。 代码 F - Abbreviation#签到。 代码 H - Singing Everywhere#删除一个点只会影响到两边是否是 “voice crack”，因此存一下前缀和后缀的 “voice crack” 的数量，再加上两边的情况即可。 代码 C - Array in the Pocket#如果最多的元素，数量是超过一半的，那就没有办法满足重新排列后满足题目的条件。 进一步地，如果需要放置的元素不为原序列 $A$，而是另外的一个大小和原序列长度相同的多重集 $S$，那么只有当所有元素在 $A$ 和 $S$ 出现的总数不超过 $|A|$，才会有解。同时，如果有元素出现的总数为 $|A|$，那么该元素重排的位置是确定的。 对于这个题目，大思路确实是尽可能地放小的，但是存在情况需要放更劣的值。 假设前面已经放好了 $i - 1$ 个元素，还剩下没有放置的元素的多重集为 $S$： 若 $a[i:n]$ 和 $S$ 的所有元素中，总数最多的元素 $v$，数量若为 $n - i + 1$（即说明 $v$ 能放的位置，对于当前情况已经是固定的了），当 $a_i \\ne v$ 时，则不得不放置 $v$ 在当前位置。 若 $a_i \\ne \\min{S}$，则可以放 $\\min{S}$。 若 $a_i = \\min{S}$，那就放次小的。 代码：写残了，可以写的更优雅一点。 D - Traveler#后期就剩下 D 和 A 在写，D 我有个和队友不一样的方法，就偷偷写了一下。 我们首先从根节点走到节点 $n$，走过这条树链后，剩下未走过的点形成若干个完全、满二叉子树。接下来通过 $i - 1$ 的边走到相邻的一个子树，然后进行从一个子树的最右端走到最左端的操作。重复这样的操作直到 $i - 1$ 走到 $n$ 所在的树链为止。 你会想说走到整棵树的最左端的叶子节点后该怎么办。会发现通过 $i - 1$ 的边可以走到整棵树浅一层的最右端的节点，也就是剩下还没有走过的点形成在最右侧子树的最右端。 实现从子树的最右走到最左操作，同时，还需要实现一下从最右走到根、从根走到最左。然后这三个操作之间递归一下即可完成子树的遍历。 代码：写残了，可以写的更优雅一点。","link":"/2020/04/11/The-16th-Zhejiang-Provincial-Collegiate-Programming-Contest/"},{"title":"AtCoder Regular Contest 084","text":"四题只做出一题，然而 Rating 涨了，应该是因为我一直都很菜吧。 综述#题数 1/4，排名 172/537。头铁，做完第一个一直在磕第二个；第二个磕不动，读第三个，比赛时题意读错（最近好多次出问题都出在这样的初期准备上，可能我需要换个脑子了）。赛后不借助题解直接补了第三题。 题意和题解#C. Snuke Festival (sort, partial sum)#给三个长度为 \\(n\\) 的数组 \\(A_i, B_i, C_i\\)，问从三个数组中分别抽出一个数 \\(A_u, B_v, C_w\\)，有多少种情况能使得 \\(A_u &lt; B_v &lt; C_w\\)。 三个数组排序。先找有多少对 \\(B_v &lt; C_w\\)，即对每个 \\(v_0\\) 记录一下有多少个 \\(C_w &gt; B_{v_0}\\)；因为数组排好序了，对每个 \\(v_0\\) 卡个指针 \\(w\\) 就可以，记这个值为 \\(b_{v_0} \\gets n - w\\)。由于对于每个 \\(u_0\\)，只要知道哪些 \\(B_v &gt; A_{u_0}\\)，那么满足题意的三元组的个数就是 \\(\\sum_{B_v &gt; A_{u_0}}{b_v}\\)，类似于处理 \\(v_0\\) 的方式搞一下就行。 时间复杂度 \\(\\mathcal{O}(n \\log{n})\\)。 D. Small Multiple (graph, shortest path)#对于给定的 \\(k\\)，找到十进制各数位和最小的 \\(k\\) 的倍数。 先考虑十进制的各数位和怎么处理。容易发现对于每个非负数 \\(u\\)，\\(10 u\\) 的各数位和与 \\(u\\) 的是相等的，\\(u + 1\\) 的各数位和则小于或等于 \\(u\\) 的各数位和加一。这样把每个非负数看作是图上的点，\\(u\\) 向 \\(10u\\) 连接一条长度为 0 的边，向 \\(u + 1\\) 链接一条长度为 1 的边。那么每个数 \\(u\\) 的各数位和就是从 \\(0\\) 到 \\(u\\) 的最短路。 而题目所需的就是 \\(0\\) 到 \\(k\\) 的所有倍数的点的最短路。把每个点模 \\(k\\)，问题就变成了从 \\(0\\) 跑回来的最短路了。 实现上可以考虑从每个 \\({10}^i\\) 出发，跑个类似分层的bfs，把长度为 0 的边能连到的点先放到同一层，把长度为 1 的放到下一层，某一层处理完了再处理下一层。搜完或者扫到 \\(0\\) 了就找到答案了。这样写起来不算困难，时间复杂度也较优。 时间复杂度 \\(\\mathcal{O}(k)\\)。 D. Small Multiple (trie?, locally bruteforce for properties?)#给两个正数 \\(n, k\\)，求长度不超过 \\(n\\) 的、由 \\(1\\) 到 \\(k\\) 的整数组成的元组，按字典序排序（长度不同则在后面补 \\(0\\)，即 \\((1, 1) &lt; (2)\\)，比赛时这里搞错了），排名居中的数组是哪个。 相当于建一个深度为 \\(n\\)，\\(k\\) 叉的 trie，并且除了根的所有点都要算作一个合法的点，求排名居中的那个点。如果 \\(k=1\\)，不多说。\\(k\\) 为偶数的时候，会发现根的左半部分和右半部分的合法点数目相同，所以我们只需要找到左半部分字典序最大的点就行，所以答案就是这个点对应的数组，即长度为 \\(n\\) 的 \\(\\frac{k}{2}, k, k, \\cdots, k\\)。 如果 \\(k\\) 为奇数，考虑每次都走节点排名居中的儿子，一直走到叶子，如果分枝结点不算做合法点数的话，这个节点对应的数组就是答案了，而这个节点的排名多了 \\(n-1\\)，因为前面多了 \\(n-1\\) 个父节点。这样我们需要在 trie 上找到从当前这个节点走到排名减 \\(\\frac{n-1}{2}\\) 的前驱。这个过程类似于平衡树找前驱的过程，对于当前的点，如果自己不是父节点的第一个儿子，则跳到父节点的前一个儿子，并且沿字典序最大的方向上一直跳到叶子，这个叶子就是前驱；如果当前节点是父节点的第一个儿子，那么前驱就是自己的父节点了，跳到父节点上就行。这样不断操作 \\(\\frac{n-1}{2}\\) 次就得到了对应答案的点了。 对于找前驱的过程，假设现在这个节点到达了第 \\(0 \\le u \\le n\\) 层，那么说明我们已经跳过了 \\(\\mathcal{O}(k^{n-u})\\) 个排名，因此不用担心找前驱的过程会跳太多次的父节点，最多只会跳到叶子节点的第 \\(\\log_k{n}\\) 级父节点。 所以时间复杂度 \\(\\mathcal{O}(n \\log_k{n})\\)。 F. XorShift#（还没读……待补）","link":"/2017/11/04/arc084/"},{"title":"AtCoder CODE FESTIVAL 2017 qual C","text":"发现能力还是差一些，依然需要努力，加油。 综述#总共6道题，前四道相当简单，后两道没法下手，最后做出4题。检查代码的时候不太认真，爆了几发，下次应该多注意。 题意和题解#A. Can you get AC?#给个字符串，查是否有子串 &quot;AC&quot;。 B. Similar Arrays#定义两数组“相似”，当且仅当对应位置元素的绝对差小于1。给个数组求多少种数组和它相似，并且那些数组元素的积为偶数。 （我……因为 \\(N\\) 太小了，当场直接交搜索……） 会发现直接算还是有点困难。逆向考虑，若数组元素的积为奇数，那就意味着其中不存在偶数元素；这个计数还是很容易的，根据原数组每一位的奇偶可以看这一位置能取得元素的种类，乘起来。答案就是相似的数组的总数 \\(3^N\\)，再减去乘积为奇数情况的数目。 C. Inserting ‘x’#给个字符串，让通过最少次数的插入 &apos;x&apos; 的操作把它整成一个回文串。 考虑让首尾两元素一致，在两端都插 x 没什么意义，如果两端一开始不同、且都不为 x，那无论怎么操作，字符串都不会成为回文串了；如果有一个是 x，那可以在另一头插个 x，让首尾先相同，这样首尾就不用再考虑了，删掉。把这样的若干次操作放到一起，相当于搞掉两头的 x，搞掉两头相同的字符，再往复这么搞。相当于把所有 x 都删掉，然后判断现在的字符串是不是回文的，“不是”就没法操作成回文的；“是”的话就考虑字符间的空隙，在每对对称位置上插 x，让字符串变成回文的。显然，每对对称的空隙所需的最少的操作次数，即是两个空隙内原有的 x 数目的绝对差。这样就得到了所需的最少的操作数。 D. Yet Another Palindrome Partitioning (dp)#给个字符串，让把字符串分成尽可能少的块，使得每块都是一个回文串的重排列。 回文串的重排列，那就是每种字符出现次数都为偶数，或者至多只有一种出现奇数次。因为都是小写字母，可以把26种字符出现奇偶次的状态存成整数；并且若维护这个状态的前缀和 \\(s_i\\)，就可以用异或方便地得到所有块的奇偶次状态。 记 \\({dp}_i\\) 为前缀 \\(1 \\cdots i\\) 的最少分块数目，\\(bc(x)\\) 为 \\(x\\) 的二进制的1的数目。很容易得到\\[{dp}_i = \\min\\limits_{\\substack{1 \\le j &lt; i \\ bc(s_i \\oplus s_j) \\le 1}} + 1\\]对于每个 \\(i\\)，枚举 \\(b\\)，找所有的 \\(j: s_i \\oplus s_j = b\\)，即找奇偶次状态等于 \\(s_i \\oplus b\\) 的 \\(dp_j\\) 的最小值，开个 unordered_map，每次都存一下 \\(s_i\\) 对应的最小的 \\(dp_i\\) 就可以 \\(\\mathcal{O}(\\Sigma*)\\) 时间内转移了。 E. National Property (sweep line)#给个由 \\(1 \\times 1 \\times 1\\) 的小立方体搭成的 \\(A \\times B \\times C\\) 大长方体（\\(A, B, C\\) 两两互质），平行于坐标轴放置，一个顶点在 \\((0, 0, 0)\\)，对面的在 \\((A, B, C)\\)，这两个顶点间穿一根线；给每个小立方体标记一个坐标，取其坐标分量最小的顶点为立方体的坐标，比如最靠近原点的那个记为 \\((0, 0, 0)\\)；记两个立方体的坐标的切比雪夫距离（各坐标绝对差中最大的值）为两立方体距离。问有多少个立方体到最近的、被线穿过的立方体的距离小于或等于 \\(D\\)。 （比赛时读完题了，但是没有什么思路。） 一个重要的结论是，线在两个顶点间，只会经过小立方体的“面”，而不会经过棱、顶点。可以把线表示成参数方程，然后令某一维坐标值为整数，会发现另外两维在顶点间都不会成为整数；同样对每一维这样讨论，就能得到三个坐标值两两间不会同时为整数。这就证明了上述结论。由这个结论，便可以发现相邻的、被线穿过的小立方体的坐标间，都是某一维差个1，具体是哪一维取决于线是经过了小立方体的哪一面；这样把相邻的小立方体记为 \\(P_0(x_0 = 0, y_0 = 0, z_0 = 0), \\cdots, P_{n-1}(x_{n-1} = A-1, y_{n-1} = B-1, z_{n-1} = C-1)\\)，因为 \\(P_{i}\\) 和 \\(P_{i+1}\\) 只有一维差了1，相当于走了一个曼哈顿路径，所以总共 \\(n = A+B+C-2\\)。 如果不考虑大长方体的限制，让空间充满小立方体，和 \\(P_0\\) 切比雪夫距离小于或等于 \\(D\\) 的所有小立方体，即符题的立方体，发现总数是 \\((2D+1)^3\\)；如果按顺序增加 \\(P_i\\)，符题的立方体每次都会在某个方向上多一个高度为1的扁平的长方体，且是在 \\(P_{i-1}\\) 往 \\(P_i\\) 走的方向上，距离为 \\(D\\) 处，增加的这些立方体，最符题立方体总数的贡献是 \\((2D+1)^2\\)。如果单纯这么考虑，那么总共的符题立方体数就很容易得到了。 若加上长方体的限制，会发现只有靠近边界的、被线穿过的立方体的贡献容易有变化，靠近中心的被线穿过的立方体的贡献就不会变化了。我们把贡献会变的被线穿过的小立方体记为关键点，用三个坐标分量的和作为关键字排序，类似于扫描线来处理相邻两个关键点的贡献。 记相邻的两个关键点为 \\(P(x, y, z),, Q(x+\\delta x, y+\\delta y, z+\\delta z)\\)，在 \\(P,Q\\) 间的所有被线穿过的立方体，在同一个方向上增长的那一些对答案的贡献是一样的。记三个方向上对答案的贡献分别为 \\(F_x, F_y, F_z\\)，则包括 \\(P\\) 不包括 \\(Q\\) 间的所有被线穿过立方体的总贡献是 \\(F_x \\delta x + F_y \\delta y + F_z \\delta z\\)。 再深入思考，在 \\(P_{i-1}\\) 转到 \\(P_i\\) 过程中，若 \\(P_{i-1}\\) 是在 \\(u \\in {x, y, z}\\) 方向上增加的贡献，而 \\(P_{i-1}\\) 的 \\(u\\) 方向上的分量小于 \\(D\\)，或者大于或等于 \\(A - D - 1\\)，则立方体 \\(P_{i-1}\\) 必是一个关键点。这样，枚举三个方向上坐标有变化的、且离两个边界距离不超过 \\(D\\) 的立方体，就可以找到所有的关键点。显然，这些关键点的总数是 \\(\\mathcal{O}(D)\\) 的。这样便能在 \\(\\mathcal{O}(D\\log{D})\\) 时间内得到符题的立方体数目了。 F. Three Gluttons (dp)#UPDATED on 2017-11-08 现在有 \\(N=3n\\) 个寿司，有三个人 A, B, C，各自有个寿司的喜好顺序列表 \\(a_i, b_i, c_i\\)，三个列表都是 \\(1\\) 到 \\(N\\) 的排列。每一次，设是第 \\(t\\) 次，三个人会按着喜好顺序从左到右，找现在还存在的寿司编号 \\(a_t, b_t, c_t\\)，然后同一个寿司最多被一个人选择的情况下，会吃掉这三个寿司，然后继续进行同样的步骤，直到吃完所有的寿司。题目则是给出 A 和 B 的喜好列表，在不出现选择的寿司有冲突的情况下，C 的喜好列表有多少种方案。 先只考虑如何计算被 C 吃的寿司的序列 \\(x_1, \\cdots, x_n\\) 的种类数。假设我们已经有了 A, B 吃的寿司的序列 \\(a_{u_i}\\), \\(b_{v_i}\\)，对于每个 \\(t\\)，肯定有 \\(a_{u_t}\\) 不在 \\((b_1, b_2, \\cdots, b_{v_t})\\) 中，对于 \\(b_{v_i}\\) 也不在 \\((a_1, a_2, \\cdots, a_{u_t})\\) 中；而 \\(x_t\\) 只要不在 \\((a_1, a_2, \\cdots, a_{u_t})\\) 和 \\((b_1, b_2, \\cdots, b_{v_t})\\) 中就没问题。但为了防止出现重复的 \\(x_i\\)，对于某个特定的 \\(t\\) 可行的 \\(x_t\\) 还需要考虑后面 A, B, C 各自吃的。记这样的 \\(x_t\\) 可以取\\[f(u_t, v_t, t) = N - \\left[3 (n - t) + \\left|\\left\\{a_1, a_2, \\cdots, a_{u_t}, b_1, b_2, \\cdots, b_{v_t}\\right\\}\\right|\\right]\\]所以，已有 A, B 的寿司序列时，\\(x_i\\) 的序列数是 \\(\\prod_{t}{f(u_t, v_t, t)}\\)。 我们用 DP 来计算总的这些合法的序列的贡献，设 \\({dp}_{i, j, k}\\) 表示 \\(u_k \\le i\\), \\(v_k \\le j\\) 时，\\(x_1, \\cdots, x_k\\) 的总序列数目。显然小一点的 \\(i\\) 和 \\(j\\) 都是在这个答案里的，所以答案至少有 \\({dp}_{i - 1, j, k} + {dp}_{i, j - 1, k} - {dp}_{i - 1, j - 1, k}\\) 的贡献（相当于维护一个矩阵和）。如果 \\(a_i\\) 没有出现在 \\((b_1, \\cdots, b_j)\\) 中，并且 \\(b_j\\) 也没出现在 \\((a_1, \\cdots, a_i)\\) 中，那么可以让 \\(a_{u_k}=a_i\\), \\(b_{v_k}=b_j\\)，然后从一些 \\(x_1, x_2, \\cdots, x_{k-1}\\) 中转移过来，即满足这种情况下的答案还有 \\(f(a_i, b_j, k) * {dp}_{i - 1, j - 1, k - 1}\\) 的贡献。 所以总的，\\(x_t\\) 的合法序列有：\\[{dp}_{i, j, k} = {dp}_{i - 1, j, k} + {dp}_{i, j - 1, k} - {dp}_{i - 1, j - 1, k} + \\begin{cases}f(a_i, b_j, k) * {dp}_{i - 1, j - 1, k - 1}, &amp;, a_i, b_j \\text{均第一次出现} \\\\ 0, &amp;,\\text{else}\\end{cases}\\] 而对于从 \\(x_t\\) 向 C 的喜好序列 \\(c_i\\) 转移时，会发现和具体的 \\(a_i, b_i\\) 没关系，因为假设 \\(p_{i,j}\\) 为已知 \\(x_t\\)，且已经吃了 \\(j\\) 次、C 已经发现喜好序列的前 \\(i\\) 个都被吃过了的情况的 \\(c_1, \\cdots, c_i\\) 种类数。对于寿司编号 \\(c_i\\)，如果 \\(c_i\\) 不是 \\(x_t\\) 中的寿司，则这里只能取前面自己没吃过，且是 A, B 前 \\(j\\) 次吃过的寿司（不然 C 会抢在 A, B 之前吃掉 \\(c_i\\)，那 \\(c_i\\) 应当在 \\(x_t\\) 中）；如果 \\(c_i\\) 是 \\(x_t\\) 中的寿司，那这一位置就只有这一种选择。所以：\\[p_{i, j} = p_{i - 1, j} (3j - i) + p_{i - 1, j - 1}\\]和 \\(a_i, b_i\\) 甚至 \\(x_t\\) 的具体值都无关。 所以最终答案是 \\({dp}_{N, N, n} * p_{N, n}\\)（查了表，实际 \\(p_{N, n}\\) 就是 A052502）。 时间复杂度 \\(\\mathcal{O}{(N^3)}\\)","link":"/2017/10/22/atcoder-code-festival-2017-qualc/"},{"title":"BCPC2017 决赛 I. 夜晚的街区","text":"出题: Chielo, 验题: skywalkert。 简明题解：DFS + 维护后缀AND和区间 + 寻找后缀最小值的变化点。 题解#直接在有向树上进行 DFS，将走过的边权视为序列 \\(a_1, \\cdots, a_n\\)，题面所需的就是后缀AND和与后缀最小值相等的情况有多少种。 算法需要保证在维护所需信息的同时，可以支持在该序列末尾加入一个元素、回退加入元素，这两种操作。 考虑两个相邻的后缀AND和 \\(A_i = \\mathrm{AND}(a_i, \\cdots, a_n)\\), \\(A_{i-1} = \\mathrm{AND}(a_{i-1}, \\cdots, a_n)\\)，有 \\(A_{i-1} = \\mathrm{AND}(a_{i-1}, A_i)\\)，显然，\\(A_i\\) 随 \\(i\\) 的减小而不严格递减。并且，若 \\(A_{i-1} \\ne A_i\\) 的话，则说明\\(A_i\\) 的二进制中至少一个 \\(1\\) 变为了 \\(0\\)，所以 \\(A_i\\) 的取值只有 \\(\\mathcal{O}(\\log{a_i})\\) 种，并且连续的若干 \\(A_i\\) 会取到相同的值。 后缀最小值 \\(M_i\\) 的分析也同理，随 \\(i\\) 的减小而不严格递减，但取值是有 \\(\\mathcal{O}(n)\\) 种。若 \\(M_{i-1}=\\min(a_{i-i}, M_i) \\ne M_i\\)，则 \\(M_{i-1} = a_{i-i}\\)。 因此，最方便的做法是 DFS 过程中，用数组或者链表维护后缀AND和区间，即 \\(i\\) 处于某区间 \\([l, r]\\) 时，后缀AND和等于定值 \\(A\\)（DFS后继的话用祖先的区间链表更新一下就行）。然后寻找后缀最小值 \\(M_j\\) 何时恰好等于 \\(A\\)，即令 \\(j\\) 最大。再想，后缀最小值 \\(M_j\\) 能恰好减小到 \\(A\\)？应当是满足 \\(a_j=A\\) 且 \\(j\\) 最大的那个元素 \\(a_j\\)。这个东西用哈希表维护一下每个元素值最大的下标就好。 （不理解可以画后缀最小值与后缀AND和的图像，找找什么时候函数值相同。） 回退的话，我们维护的区间存起来就行，空间存得下；哈希表因为每次只会改一个映射，递归完恢复一下就可以。不用哈希表也可以，因为映射的值就那 \\(\\mathcal{O}(n)\\) 个，可以离散化，用数组存，复杂度虽然劣一些，但是常数较优，跑的反而快很多。 比赛结果分析#这一道题，确实是乱搞题。 但是因为比赛时的数据边权几乎是随机的（忘记处理了），比赛的最后时刻，一名校内的大一选手大胆猜测，写了个 \\(\\mathcal{O}(n^2)\\) 暴力+剪枝，拿了现场赛唯一的 Accepted（现在 OJ 上另外加了数据增强的题目了，但是数据范围没变）。 网络赛中，唯一的 Accepted 提交来自栗子老师，（似乎是）用的二分+ST找最小值的位置；怎么维护的AND和区间没看懂，空间复杂度是 \\(\\mathcal{O}(\\log{a_i})\\) 的（似乎是找每一位在哪一深度被置为 \\(0\\)）；如果不用二分+ST应该是最优的做法吧；在DFS过程中更新ST，这一点值得学一下。 标程#使用 unordered_map，时间复杂度 \\(\\mathcal{O}(n\\log{a})\\)，空间复杂度 \\(\\mathcal{O}(n\\log{a})\\)。离散化，时间复杂度 \\(\\mathcal{O}(n\\log{n}\\log{a})\\)，空间复杂度 \\(\\mathcal{O}(n\\log{a})\\)。","link":"/2017/12/18/bcpc-2017-I/"},{"title":"BCPC2017 预赛 E. 气球派对","text":"出题: Chielo, 验题: chitanda。 简明题解：奇偶染色 + 二分图最小点覆盖 + Kőnig 定理。 题解#容易发现，从圆上或圆内任意一整点开始进行奇偶染色，就将原图转化为二分图了（容易从每个点到出发点的曼哈顿距离的奇偶性证明这一点）。 记转化后的二分图为 \\(B(V = L \\cup R, E)\\)，那么问题就变为： 选取若干个点构成点集 \\(S \\subseteq V\\)，使得每条边 \\(e \\in E\\) 都与 \\(S\\) 中至少一个点相邻。实际就是二分图的最小点覆盖问题。 由 Kőnig 定理，我们就知道了这个 \\(S\\) 的大小恰好等于完美匹配的大小，并且构造方法也在定理中阐述了。 构造与证明#QwQ，我还是好好地给出构造方案和证明吧。 构造#假设已经用匈牙利算法得到了完美匹配的一个方案，从每个 \\(L\\) 中未匹配的点出发，在不清空时间戳的情况下，搜索增广路，即进行 dfs。正常情况下应该搜不出来新的增广路。那么 \\(L\\) 中所有的未被访问到、且是匹配点的点集 \\(L’\\)，和 \\(R\\) 中所有被访问到的、且是匹配点的点集 \\(R’\\)，两者的并集就构造出了最小点覆盖 \\(S_0\\)。 用网络流的说法就是：设 \\(E\\) 中的边流量为 \\(1\\)，源点向 \\(L\\) 的每个点连接流量为 \\(1\\) 的边，\\(R\\) 的每个点向汇点连接流量为 \\(1\\) 的边。获得一个最大流的方案后，在残余网络中从源点出发进行染色。所有源点到 \\(L\\) 的边跑满并且未被染到的点以及所有 \\(R\\) 到汇点的边跑满并且被染到的点，构成的集合是一个最小点覆盖 \\(S_0\\)。这个过程和匈牙利的做法本质是相同的。 证明#\\(|\\text{最小点覆盖}| \\ge |\\text{完美匹配}|\\)#由于完美匹配构成的边集都是互不相邻的，即都没有公共的点，而最小点覆盖又需要把所有边都覆盖到，所以 \\(S\\) 的大小至少要大于或等于完美匹配的大小。 \\(|S_0| = |\\text{完美匹配}|\\)#由我们的构造方案知，这等价于证明每条匹配边 \\(e=(u,v)\\) 的两个点染色情况相同。在残余网络中搜寻的过程中，若 \\(u \\in L\\) 被遍历到，但由于 \\(u\\) 是匹配点，不是我们遍历过程的起始点，因此它必然是从 \\(v\\) 那里顺着反向边过来的；而若 \\(v \\in R\\) 被遍历到，那由于这条边是流满的，反向边还有流量，那么 \\(u\\) 必然也被遍历到。所以，\\(u\\) 被染色，当且仅当 \\(v\\) 被染色，逆否命题也成立。 综上，完美匹配中的每条边，两个端点 \\(u,v\\) 的染色情况是相同的。而我们的构造过程也是从匹配边端点的访问情况进行二选一，所以 \\(S_0\\) 的大小恰好等于完美匹配的大小。 \\(S_0\\) 是一个点覆盖#假设有条边 \\(e=(u,v) \\in E\\), \\(u \\in L\\), \\(v \\in R\\)，未被 \\(S_0\\) 中的点覆盖。 引理部分： 由于 \\(S_0\\) 是从完美匹配中构造出来的，所以匹配边肯定是被覆盖到的，因此 \\(e\\) 是非匹配边。 而若 \\(e\\) 是非匹配边，那么两个点必然不能同时是非匹配点，否则这条边可以用来增广，那么先前的匹配就不是完美匹配了。 由于 \\(e\\) 未被覆盖，所以 \\(u, v\\) 均不在构造的 \\(S_0\\) 中，这样就可以从 \\(u, v\\) 的染色情况得到 \\(u, v\\) 是否是匹配点的信息。 证明部分： 假设 \\(u, v\\) 均未被染到，那么 \\(u\\) 肯定不是遍历的起点，即 \\(u\\) 是匹配点，那么 \\(u \\in S_0\\)，这个边是覆盖到的，矛盾； 假设 \\(u, v\\) 均被染到，因为 \\(u, v\\) 均不在 \\(S_0\\) 中，所以 \\(v\\) 只能是非匹配点，由于不能同时是非匹配点，所以 \\(u\\) 也只能是匹配点，那这两个点同时被染到，不就相当于找到了一条增广路吗，匹配不是完美匹配，矛盾； 假设 \\(u\\) 未被染到，\\(v\\) 被染到，但 \\(u, v\\) 均不在 \\(S_0\\) 中，那这两个点都不能是匹配点，与不能同时是非匹配点矛盾； 假设 \\(u\\) 被染到，\\(v\\) 未被染到，但 \\(e\\) 是非匹配边，在残余网络中是有流量的，\\(u\\) 被染到，接下来肯定会染到 \\(v\\)，与构造方式矛盾。 综上，\\(e=(u,v)\\) 不管什么情况，都会有矛盾，所以由反证法，\\(e\\) 不可能存在，因此所有边都被覆盖到了。 证明总结#\\(S_0\\) 是一个大小等于完美匹配的点覆盖，而最小点覆盖的大小是大于或等于完美匹配的大小；因此我们找到了 \\(S_0\\) 是点覆盖中，大小取到最小值的那个，所以 \\(S_0\\) 是一个最小点覆盖。 实际，通过上面的构造和证明，很容易发现若 \\(u \\in L\\) 没被染，它肯定是个匹配点，若 \\(v \\in R\\) 被染，如果 \\(v\\) 是个非匹配点就找到增广路了，所以 \\(v\\) 也肯定是个匹配点。所以构造的时候可以不需要判是否是匹配点。 比赛结果分析#当时，出到这一道的时候图论题还不是很多。所以本来这道题，是按图论+定理题+中前期出的，运用到了常见的二分图模型——网格图，以及 Kőnig’s theorem。但是听说 OnlineJudge 支持 SPJ，所以写了一个 SPJ 试了试，结果没想到好多人卡在“方案”这一步了。最后通过率 7/9，都是前排选手在后期AC的（看来卡题意了）……略遗憾。 这个定理常用它的结论，也就是最小点覆盖和完美匹配相等这一点，但实际定理中是有阐述出如何从匹配构造出点覆盖的，所以对定理的学习也应该深入一些（讲给自己）。 标程#匈牙利算法ISAP","link":"/2017/12/17/bcpc-2017-pre-E/"},{"title":"Codeforces Round #441 (Div. 2)","text":"嗯……好久不练习了。这一场的时间很好，所以试试参加。结果上看还好。 综述#总共 6 道题，整体还是比较简单的。A、B、C、D、F 一次 Accepted，E 题只读题，没时间做了，赛后补掉了。C 题想的有点慢，F 写的有点慢。 题意和题解#A. Trip For Meal#加权无向无自环的三元图，问固定起点最短的有 \\(n\\) 个点的路径为多长。 显然在最短的边上抖动就好，如果那条边不和起点关联就走个最短的先过去。 B. Divisiblity of Differences#给 \\(n\\) 个数，选 \\(k\\) 个模 \\(m\\) 同余的。 开 \\(m\\) 个桶，扔到对应余数的就行。随便找一个符题的桶输出就好。 C. Classroom Watch#给一个数 \\(x\\)，找有哪些 \\(n\\)，满足 \\(n\\) 的十进制的各位和 \\(s\\) 与 \\(n\\) 的和等于 \\(x\\)。 \\(s\\) 范围很小，枚举 \\(s\\)，有 \\(n_0 \\gets x - s\\)，看看得到的 \\(n_0\\) 的各位和是不是 \\(s\\) 就行。 D. Sorting the Coins#给一个长度为 \\(n\\)，初始全为0的数组，会有 \\(n\\) 次操作把数组的某一个位置改为1，问当前情况下，如果用冒泡排序，排完前最多会扫几次。 考虑最右边的0，找到它左面第一个1，这个1肯定会被换过来，并且刚好换到排好序的位置上；其它的1会与其右边连续的若干个0交换位置，但依然没有被交换到排好序的位置上，继续从头进行同样的操作，直到发现数组已经排好。这样就发现，排序的扫描次数就是从右边第一个0开始，左边的1的个数加一。所以，记一下总共有多少个1，末尾有多少个连续的1，两者的差加一即为答案。 E. National Property (2-sat)#有 \\(n\\) 个数组，长度分别为 \\(l_i\\)，数组的元素为正整数都小于或等于 \\(m\\)，初始时数组的每个元素为“小写”，现在你可以让某些数字全部变成“大写”，让这些数组变成字典序升序（即大写小于小写，其余按正整数的比较方式比较）。 两两间比较时，遇到的第一个不同的位置会对这两个数字的大小写进行限制。比如两者关系在小写的时候是符合字典序的，那这两个数字应同时大写或同时小写；如果不符合字典序就直接限制在前面的数字取大写，后面的取小写；如果前缀都一样，但是前面的比后面的长，那答案就只能是否定了。这显然是一个 2-sat 模型，跑一个解就行。（对这个模型太不熟悉了，当时没想到） F. High Cry (two pointers)#给个长度为 \\(n\\) 的数组 \\(a_i\\)，求有多少个区间 \\([l, r)\\) 满足区间内所有值的二进制或严格大于区间最大值。 卡住右端点 \\(r\\)，考虑每一个左端点内区间的性质。会发现“区间或”的取值的个数是 \\(\\mathcal{O}(\\log{a})\\)，并且随左端点远离右端点，“区间或”单调不减，这样就可以维护“区间或”相同的左端点的范围了；进一步会发现“区间或”实际是大于或等于区间最大值的，为了方便，可以计算区间最大值刚好等于区间或的左端点范围（倒立做题）；由于区间最大值也有单调不减的性质，因此可以对于每个“区间或”的值和区间，找在区间内和这个值相等的、最靠右的元素位置（开个 map 就行），从这个元素开始到“区间或”所在的区间的左端点就都是不符题的左端点范围了。","link":"/2017/10/19/cf876/"},{"title":"Chess Puzzle - ICPC 长春区域赛 2015","text":"题意#给一个 $n \\times m$ 的棋盘，每个位置有空、黑、白三种情况。现在需要填充空的位置，使得颜色不同的、行坐标差为 $a$、列坐标差为 $b$ 的棋子对数尽可能多。但要给出字典序最小的解。 题解#如果是数颜色相同，也不给方案，就简单的多。每个位置可以看作网络流上的一个点。如果和 S 划在一起，则认为这个位置放黑棋子，和汇点划一起则放白棋子。坐标距离满足限制的两个点互相连一个容量为 1 的边，如果两个位置颜色不同则会割到这条边。 但现在是颜色不同，需要换一下意义。 容易发现满足坐标距离限制的点可以黑白染色（下文改称红蓝），每 $a$ 行一组，红蓝交替染色（前 $a$ 行染红，接下来 $a$ 行染蓝……）。 红点若和 S 划一起，则认为这个位置放黑的；蓝点若和 S 划一起，则认为放白的；反过来相对应的红 T 染白，蓝 T 染黑。 这样连边和上面颜色相同时候的情况也是一样的，距离满足限制的互相连容量为 1 的边，这样连接的肯定分别是红蓝两点。 强制让某个点为黑或白棋子，则按上面的红蓝点和源汇的关系连一个无穷大的边即可。 答案即为距离满足限制的点对数量，减 S-T 最小割的值。 方案#方案是个麻烦东西，还要字典序最小。 从上到下、从左到右，贪心看这个点能不能染黑的。 在残余网络上，从源点出发染色、从汇点出发反向染色，若这个点在残余网络上和源点相连，则说明必然把它和 S 割在了一起；反之和 T 割在一起。 对于没有染到的点，那这个点可以是黑的。此时已知该点为黑色的，潜在地需要再根据上面的所说的和源或汇连边，跑网络流，并再进行染色。但这不必要，因为答案已经不会改变，所以可以直接假装这个点和源或汇有边，在之前染色的基础上再染色。 类似于已知某个点是黑棋子，然后根据已知情况去递归放空位置的黑白棋子，以避免后续错放成黑的。 代码#UVALive 7191 - ISAP","link":"/2019/09/08/changchun-regional-2015-chess-puzzle/"},{"title":"BZOJ 2115, HDU 5544 最大化无向图可重复路径边权异或和","text":"题意#两个题的题意基本相同。 求连通无向图的一条路径，可以重复经过点、边，使得路径边权的异或和最大。 题解 证明（短） 证明（长） 无向图回路的边权的异或和，可由小环组成 小环的任意组合，可以有回路相对应 总结 代码 题解# 已知一组数，求选出若干个值使得异或和最大。 这是一个经典问题，可以从线性基中贪心构造出答案。 对于这两个题，DFS 后会将边分为树边和非树边。求出所有只有一条非树边构成的简单环，以这些小环的“边权异或和”构造线性基，贪心求答案即可。 （所有只有一条非树边构成的环的边权异或和：记录一下根到每个点的边权异或和 \\(a_u\\) 后，对每个非树边 \\((u, v, w)\\) 算一下 \\(a_u \\oplus a_v \\oplus w\\) 即可，公共祖先的那部分边权会异或成 \\(0\\) 的。） BZOJ 2115 需要选一条 \\(1\\) ~ \\(n\\) 的路径边权异或和作为初始值，贪心优化答案；对于 HDU 5544，直接从 \\(0\\) 贪心。 证明（短）# 主要关心的还是走过奇数次的边，这些边的边权对答案有贡献。 任何一个回路，如果有非树边走了奇数次，那你可以顺着树边绕过去走一下这个非树边再原路回去； 非树边中走过次数的奇偶性也只有这条边改变了，被走过了偶数次； 而这个新加的路径的异或值就是包含这条非树边的小环的边权异或和； 消来消去回路上就没有非树边走过奇数次了，而又不能仅有树边走过奇数次，所以这时所有边已经都被走过偶数次了，边权异或和是 \\(0\\)。 所以对任何一个回路，总能有一组小环的边权异或和的异或，与这个回路的边权异或和相对应。 小环的随便组合后，从根出发绕这些小环都走一遍，就能够构造出来一个回路，使得走过的奇数次的边集，和这些小环异或出来的边集相同。 所以小环的边权异或和的随意组合、异或，总能构造一个回路的边权异或和，与小环的相对应。 综上，任何一个回路的边权异或和的集合，和若干小环随意组合的边权异或和的集合是相同的，所以问题就能规约到题解所说的做法。 证明（长）#以下基于 HDU 5544 的题面进行证明。 下面统一称“DFS 后、只有一条非树边构成的简单环”为小环。 无向图回路的边权的异或和，可由小环组成# 对于连通的无向图，任意的一条可重复经过点、边的回路，回路的边权异或和，可以由若干小环的边权异或和，异或得到。 记这个回路为 \\(D\\)，起点为 \\(S\\)，终点为 \\(T\\)，经过奇数次的边集为 \\(C\\)。 \\(S = T\\)。 回路 \\(D\\) 的边权的异或和等于 \\(C\\) 边权的异或和。 若 \\(C\\) 中，没有非树边，即非树边都经过了偶数次。 假设有树边 \\(e = (u, v, w)\\) 在边集 \\(C\\) 中。 树边 \\(e\\) 把 DFS 树划分为两个联通块 \\(A\\), \\(B\\)； 由于非树边最终都只经过了偶数次，按回路的顺序在点间移动，\\(e\\) 经过奇数次、非树边经过偶数次以后，必然起点 \\(S\\) 和终点 \\(T\\) 分别处在不同的联通块 \\(A\\), \\(B\\) 中； 这样有 \\(S \\ne T\\)，矛盾。 因此不会有树边只经过了奇数次，\\(C\\) 中又没有非树边，所以 \\(C\\) 为空集。 所以所有边都只经过了偶数次，回路的边权异或和为 \\(0\\)。 若 \\(C\\) 中，有非树边。 记 \\(C\\) 中某个非树边为 \\(e = (e_u, e_v, e_w)\\)； 记小环中，包含 \\(e\\) 的简单环为 \\(D_e\\)。 按以下步骤，在不引入新的经过奇数次的非树边的情况下，构造一个新回路 \\(D’\\) 使得 \\(e\\) 经过了偶数次： 从 \\(C\\) 中的起点 \\(S\\) 出发，只经过树边，走到点 \\(e_u\\) 后，按 \\(D_e\\) 走一遍简单环，再从点 \\(e_u\\) 原路返回至 \\(S\\)，记这个回路为 \\(P\\)。 将这个回路 \\(P\\) 拼到 \\(D\\) 的末尾，拼成路径 \\(D’\\)，显然 \\(D’\\) 依然是个回路。 记 \\(D’\\) 中经过奇数次的边集为 \\(C’\\)。 由于回路 \\(P\\) 中，只有 \\(D_e\\) 的边经过了奇数次，而 \\(e\\) 是 \\(P\\) 中唯一的非树边，所以 \\(P\\) 中经过奇数次的非树边只有 \\(e\\)。 所以在 \\(D’\\) 中 \\(e\\) 总共经过了偶数次，\\(C’\\) 中已经没有了 \\(e\\)。 在 \\(P\\) 中又没有其它非树边，所以 \\(C’\\) 中也没有引入新的非树边。 我们成功地从回路的经过奇数次的边中，踢掉了一个非树边。 对于答案，如果知道回路 \\(D’\\) 的边权异或和 \\(ans’\\)，那么 \\(D\\) 的边权异或和 \\(ans\\) 就为 \\(ans’\\) 异或上简单环 \\(D_e\\) 的边权异或和。 通过上述的归纳证明，任何一种回路 \\(D\\) 的边权异或和，都可以用若干小环的边权异或和，异或得到。 小环的任意组合，可以有回路相对应# 对于任何一种小环的组合，我们都可以构造一个指定起点 \\(S\\) 的回路 \\(D\\)，使得 \\(D\\) 的边权异或和，恰好等于这组小环边权异或和的异或和。 构造方法就是对每个小环，从 \\(S\\) 点出发，走到小环的某个点上，再绕这个小环走一圈后，原路返回到 \\(S\\) 点。 这样把所有小环走一遍就得到了一个从 \\(S\\) 出发的回路 \\(D\\)，并且显然 \\(D\\) 的边权异或和，就是这些小环各自的边权异或和的异或和。 总结#回路、小环的任意组合，这两者都能有一个边权异或和相等的映射。 因此无向图中，求可以重复经过点、边的回路的边权异或和的最大值，等同于求小环边权异或和，任意异或能够得到的最大值。 代码# BZOJ 2115 HDU 5544","link":"/2018/11/13/connected-undirected-path-xor/"},{"title":"开个小博客，沉浸在自己的空间","text":"不再年轻了，即将 20 岁，想看看自己留下过的足迹。开个小博客，记录一下自己的生活、参加的比赛，也写一些小教程，记录、分享竞赛里见过的技巧。 大学已经过了一年了，发现选个好大学很重要呐。早知道当初高三就不要那么努力，到现在选了这么一个把“学习”捧得那么高的大学，而且尽是些老旧、无聊，甚至是和专业完全无关的课程，多少是有些后悔的。 但已经走到现在了，稍微坚持一下，慢慢积累，相信会看到自由、美好的未来的。 博客由 Hexo 强力驱动，主题使用 Minos。","link":"/2017/10/18/preface/"},{"title":"zkw线段树","text":"（虽然是旧时代的东西了，但是拿出总结总结还是可以的） 介绍#zkw线段树是线段树的一种非递归实现，比递归版高效，并且引出了更多关于线段树的性质。 标号#假设我们要为某个长度为 \\(N\\) 的序列 \\(a_i , (0 \\le i &lt; N)\\) 维护一些区间信息，先令 \\(m = 2^{\\lceil\\log_2{N}\\rceil}\\)，建立有 \\(m\\) 个叶子的线段树，显然是个满二叉树。将根节点标号为 \\(1\\)，记其深度为 \\(0\\)；然后从浅到深，接着上一层的标号，依次为每一层连续标号。这样开个 \\(2 m\\) 长的数组就能存下整棵树了。 会发现这样的标号相当于每个节点的左儿子标号是自己的2倍，右儿子则是左儿子的标号加个1；用二进制表示就是左移1位，是左儿子，再或个1，是右儿子。自己的父亲的标号也就可以通过自己的标号除以2获得，即直接右移1位。而又因为每一层是接着上一层的 \\(2^i - 1\\) 开始标号的，每一层最左边的节点就是 \\(2^i\\)，最右边就是 \\(2^{i+1}-1\\)。二进制来看就相当于这一层的最高位的1都在同一位，删掉这一位的1，这一层的标号就相当于从0开始标到 \\(2^i - 1\\)。那么最左边的叶子标号也就是 \\(2^{\\lceil\\log_2{N}\\rceil} = m\\)。 由于有了上面的这些性质，想要定位到原来序列的元素 \\(a_i\\) 对应的叶子就比较容易了，给 \\(i\\) 加个 \\(m\\) 就好了，即是说 \\(a_i\\) 对应的叶子节点的标号是 \\(i + m\\)。如果想要从深到浅地遍历祖先，不断右移标号就行。 线段树操作#平常我们使用线段树，都是叶子存 \\(a_i\\)，让其它节点存储其下连到的所有叶子的区间信息。那么对于线段树的单点操作，就是修改叶子节点并维护祖先节点的信息；而对某个区间 \\([l, r): 0 \\le l, r &lt; N\\) 的操作，就是找刚好被这个区间覆盖的所有节点，然后再处理对应子区间的信息。 单点修改+区间查询#建树#由于zkw线段树标号是连续的，可以直接从大到小遍历节点完成树的建立。比如假设叶子节点已经存好值了，用 seg[i] 维护区间和：1234567const int m = 1 &lt;&lt; 17;long long seg[m &lt;&lt; 1];void build() { for(int i = m - 1; i &gt; 0; --i) seg[i] = seg[i &lt;&lt; 1] + seg[(i &lt;&lt; 1) | 1];} 单点修改#接着上面的例子，如果只是对单点 \\(a_i\\) 进行修改，由于叶子节点很好定位，父节点遍历也很方便，实现起来很简单：123456void modify(int k, int v) { k += m; seg[k] = v; for(; k &gt; 0; k &gt;&gt;= 1) seg[i] = seg[i &lt;&lt; 1] + seg[(i &lt;&lt; 1) | 1];} 区间查询#在zkw线段树上，我们可以很容易得到操作区间 \\([l, r)\\) 对应叶子节点所在的区间 \\([l + m, r + m)\\)。但线段树不是直接修改这个区间里的所有节点，而是往祖先上走，找到刚好盖住这些叶子的分支节点。 记一对左右指针 \\(u, v\\)，分别指向 \\(u \\gets l + m\\)，\\(v \\gets r + m\\)。我们试着一直让两个指针在同一层，慢慢地往祖先移动，然后逐层得到所需的分支结点。 若左指针 \\(u\\) 指向的是其父节点的左儿子，即 \\(u\\) 是偶数，那么父节点所覆盖的区间的左边界和 \\(u\\) 指向的节点是一样的，这样 \\(u\\) 指向的节点并不是我们需要的分支结点；若 \\(u\\) 指向的是右儿子，即 \\(u\\) 是奇数，那他父亲所覆盖的区间的左边界就超出我们所需的区间了，那 \\(u\\) 节点就是我们所需的节点之一，它所覆盖的所有节点都是在我们操作区间内的节点，那我们就在 \\(u\\) 节点上处理一下区间信息。接下来移动到浅一层，若 \\(u\\) 是偶数，直接除以2、指向父节点就行；若 \\(u\\) 是奇数，\\(u\\) 节点所覆盖的区间信息我们已经处理了，那我们需要让 \\(u\\) 指向含有右边区间的信息的节点，而 \\(u\\) 和 \\(u + 1\\) 作为同一层相邻的两个节点，刚好覆盖的也是相邻两个区间的信息，所以我们让 \\(u\\) 自增，然后再指向自增后的父节点，就完成了 \\(u\\) 指针的转移。 同样地，对于右指针 \\(v\\)，由于它指向的是区间的开的右边界，所以和 \\(v\\) 同一层的节点 \\(v - 1\\) 才是盖到操作区间的节点。类似左指针的讨论，若 \\(v\\) 是偶数，那么 \\(v - 1\\) 的开的右边界等于 \\(v\\) 的闭的左边界，\\(v\\) 的父亲的左边界和 \\(v\\) 是相同的，所以不需要在这一层为右指针进行操作；若 \\(v\\) 是奇数，那么父节点的左边界就变掉了，而 \\(v - 1\\) 刚好是覆盖我们操作区间右边的一块信息，那么 \\(v - 1\\) 就是我们所需的分支结点，在 \\(v - 1\\) 上处理一下区间信息。转移到浅一层时，若 \\(v\\) 是偶数，则直接除以2，若 \\(v\\) 是奇数，自减与否父节点是不变的，可以直接除以2（实现上可以自减一下，因为需要 \\(v - 1\\) 的值）。这样就完成了 \\(v\\) 指针的转移。 由于 \\(u\\) 和 \\(v\\) 分别指向闭的左边界和开的右边界，所以正常情况下 \\(u &lt; v\\)，那当 \\(u &gt;= v\\) 时，显然我们已经遍历了所有需要处理信息的节点，这时迭代就可以结束了。 还是之前的例子，查询区间 \\([l, r)\\) 上的和：1234567891011long long query(int l, int r) { // Query sum of a_l, ..., a_{r-1} long long ans = 0; for(int u = l + m, v = r + m; u &lt; v; u &gt;&gt;= 1, v &gt;&gt;= 1) { if(u &amp; 1) ans += seg[u++]; if(v &amp; 1) ans += seg[--v]; } return ans;} 区间修改+单点查询#假如我们想维护一个序列，支持一个区间的所有元素加一个数，支持求某一位置的值。那么我们的节点可以用来存对应区间的总的变化量，单点查询就是将叶子及其祖先所有的值加起来。建树的话分支节点清空成0就行，其它操作的实现：1234567891011121314151617void modify(int l, int r, int d) { // Add d to a_l, ..., a_{r-1} for(int u = l + m, v = r + m; u &lt; v; u &gt;&gt;= 1, v &gt;&gt;= 1) { if(u &amp; 1) seg[u++] += d; if(v &amp; 1) seg[--v] += d; }}long long query(int k) { long long ans = 0; for(k += m; k &gt; 0; k &gt;&gt;= 1) { ans += seg[k]; } return ans;}如果是想让某个区间的所有值都等于一个数，分支节点可以存值的同时，存一下时间戳，查询查祖先链上最新的值就行。 这一类的标记的设计经常被称作是标记永久化。 区间修改+区间查询#非递归线段树有一个问题，它是自底向上的，但是我们通常的懒惰标记都是需要下传的，即需要自顶向下。那zkw线段树如何解决这一类问题呢？ 标记下传+信息收集#我们观察一下没有需要下传的标记时，区间修改的那些节点有什么的规律。先考虑我们之前区间修改的右指针，为了实现上好看一点，我们往祖先上转移时自减了一下，但是本来右指针指向的就是右儿子，自减和不自减的祖先是一样的。所以叶节点 \\(r + m\\) 的所有祖先也是我们右指针需要处理区间信息的节点的祖先。那如果我们先直接在这一条祖先链上自顶向下地下传标记，我们不就完成了正常线段树右半部分节点下传标记的工作了？实现时可以使用 \\(r + m\\) 的所有二进制前缀，就能自顶向下地遍历祖先了。 对于左半部分的节点，如果我们定义一个假的左指针为 \\(u’ \\gets l + m - 1\\)，维护 \\(u’\\)，使得 \\(u’\\) 所指的节点的开的右边界是 \\(u\\) 节点的左边界。当 \\(u’\\) 是偶数时，相当于原来的左指针 \\(u = u’ + 1\\) 节点是右儿子，是我们需要处理的节点，\\(u\\) 和 \\(u’\\) 同时自增，再转移至祖先；\\(u’\\) 是奇数时，\\(u\\) 不是我们需要的节点，两个都转移至祖先继续操作。会发现 \\(u’\\) 和 \\(v\\) 一样，自增不自增的父亲、甚至是祖先都一样的，而观察操作的过程会发现 \\(u’\\) 走过的祖先链的儿子包括了所有 \\(u\\) 需要处理的节点。因此在叶节点 \\(l - 1 + m\\) 的祖先链上，自顶向下地下传标记就完成了左半部分的下传标记。 这时，我们已经保证所有我们需要做区间修改的节点的所有父亲都把标记传给了儿子。同时，由于我们是从祖先上沿着一条连续的链进行处理，所以可以保证所有需要得到父亲标记的节点都正确地按拓扑序处理好了。 最后，当我们处理完所有区间的节点，还需要更新它们的祖先的信息，这个时候需要自底向上地处理。那么只需要自底向上地更新叶子 \\(l - 1 + m\\) 和 \\(r + m\\) 的祖先链的信息就好，相当于一次单点修改。 实现#下面以区间加一个数，区间查总的和为例，实现zkw线段树：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int bc = 18, m = 1 &lt;&lt; bc;long long seg[m &lt;&lt; 1], tag[m &lt;&lt; 1];inline void setTag(int u, int d, int l) { seg[u] += d * (long long)l; tag[u] += d;}inline void collect(int u) { seg[u] = seg[u &lt;&lt; 1] + seg[(u &lt;&lt; 1) | 1]; tag[u] = 0;}void build() { for(int i = m - 1; i &gt; 0; --i) collect(i);}void propagate(int leaf) { if(leaf &lt; m || leaf - m &gt;= m) // Not a leaf return; for(int i = bc, l = m, u; i &gt; 0; --i, l &gt;&gt;= 1) { u = leaf &gt;&gt; i; if(tag[u]) { setTag(u &lt;&lt; 1, tag[u], l &gt;&gt; 1); setTag((u &lt;&lt; 1) | 1, tag[u], l &gt;&gt; 1); tag[u] = 0; } }}void upgrade(int k) { if(k &lt; m || k - m &gt;= m) // Not a leaf return; for(k &gt;&gt;= 1; k &gt; 0; k &gt;&gt;= 1) collect(k);}void modify(int l, int r, int d) { // Add d to a_l, ..., a_{r-1} propagate(l - 1 + m); propagate(r + m); for(int u = l + m, v = r + m, w = 1; u &lt; v; u &gt;&gt;= 1, v &gt;&gt;= 1, w &lt;&lt;= 1) { if(u &amp; 1) setTag(u++, d, w); if(v &amp; 1) setTag(--v, d, w); } upgrade(l - 1 + m); upgrade(r + m);}long long query(int l, int r) { // Query sum of a_l, ..., a_{r-1} propagate(l - 1 + m); propagate(r + m); long long ans = 0; for(int u = l + m, v = r + m; u &lt; v; u &gt;&gt;= 1, v &gt;&gt;= 1) { if(u &amp; 1) ans += seg[u++]; if(v &amp; 1) ans += seg[--v]; } return ans;} 总结#以上就是zkw线段树大致的思路以及实现，相比递归版，少了递归栈，但依然可以处理大部分递归的线段树的任务，并且更加高效。 边界问题#现在再回头看一些小细节，比如区间的左边界是 \\(0\\)，或者开的右边界是 \\(m\\)，会出现什么事情呢？左边界是 \\(0\\)，叶子也就是 \\(m\\)，祖先链永远都是某个节点的左儿子，区间操作时除非是根，否则不会去进行操作；右边界是 \\(m\\)，那这个叶子并不存在，但可以认为这是一个比叶子还深的一个节点，那么在比较时 \\(v\\) 永远是大于 \\(u\\) 的，除非 \\(u\\) 指向了某一层最右边的节点，由于这是个某个节点的右儿子，处理完后会自增，变到下一层，然后就有 \\(u=v\\)，遍历就结束了。如果这两个条件同时成立，会发现直到 \\(u=1\\), \\(v=2\\) 时，会处理一下根的信息，然后转移至浅一层的时候有 \\(u=v=1\\)，就结束了。因此上面给出的实现是完全可以处理边界的情况的。 Trie#如果把zkw线段树看作是字符集为 \\({0,1}\\) 的 Trie，会发现标号的二进制就是前缀多个 1 的 Trie 对应的字符串。 树状数组#如果在线段树上倒着从第 \\(N\\) 个叶节点，将叶节点及其所有的祖先标同一个号，标过的祖先不给标，我们得到的实际就是树状数组（Fenwick Tree），这也是为什么很多人称之为没有右儿子的线段树。 zkw线段树相比于树状数组，用了更多的空间，常数还更大；但是树状数组没有办法在 \\(\\mathcal{O}{(\\log{n})}\\) 时间内解决没有区间减性质的问题，比如单点修改，求区间最大值（网传的做法的时间复杂度应该是 \\(\\mathcal{O}{(\\log^2{n})}\\) 的，每次往前走 \\(\\log\\) 层，然后减一，再继续走，最多走 \\(\\log\\) 次；也可以通过计数发现复杂度不是 \\(\\mathcal{O}{(\\log{n})}\\)），zkw线段树则可以很正常地处理只有区间和性质的问题。其次，zkw线段树可以有懒惰标记等等的东西，可以比树状数组多处理一些问题。 其它#再有一点，由于需要修改的节点标号可以预先确定，并且只有 \\(\\mathcal{O}{(\\log{n})}\\) 个，可持久化，或者简单的回退操作都可以很轻松地使用zkw线段树完成。 zkw线段树好处就是不需要记录左右儿子的指针，这样对应的缺点也很明显，它是连续标号的，不能够离散化位置的序列就不可以用zkw线段树处理了，节点开不了那么多。这样想要处理区间问题还是随用随开空间的递归版线段树好一些。 总之，zkw线段树是线段树的一种高效的非递归实现，在比赛中还是很实用的（好调）。不过，它只是实现，对于具体的问题，还需要多考虑如何构建线段树，节点需要维护哪些信息等等的问题。这样才能自如地使用各种各样的实现，让线段树成为自己强大的武器。","link":"/2017/11/05/zkw-segment-tree/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"DOMjudge","slug":"DOMjudge","link":"/tags/DOMjudge/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"Codeforce Gym","slug":"Codeforce-Gym","link":"/tags/Codeforce-Gym/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"训练","slug":"训练","link":"/tags/%E8%AE%AD%E7%BB%83/"},{"name":"Atcoder","slug":"Atcoder","link":"/tags/Atcoder/"},{"name":"BCPC","slug":"BCPC","link":"/tags/BCPC/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"二进制","slug":"二进制","link":"/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"暴力","slug":"暴力","link":"/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"Kőnig 定理","slug":"Konig-定理","link":"/tags/Konig-%E5%AE%9A%E7%90%86/"},{"name":"ICPC","slug":"ICPC","link":"/tags/ICPC/"},{"name":"区域赛","slug":"区域赛","link":"/tags/%E5%8C%BA%E5%9F%9F%E8%B5%9B/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最大流","slug":"最大流","link":"/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"最小割","slug":"最小割","link":"/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"},{"name":"BZOJ","slug":"BZOJ","link":"/tags/BZOJ/"},{"name":"HDU","slug":"HDU","link":"/tags/HDU/"},{"name":"无向图","slug":"无向图","link":"/tags/%E6%97%A0%E5%90%91%E5%9B%BE/"},{"name":"线性基","slug":"线性基","link":"/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"},{"name":"回路","slug":"回路","link":"/tags/%E5%9B%9E%E8%B7%AF/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"categories":[{"name":"比赛记录","slug":"比赛记录","link":"/categories/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"},{"name":"随记","slug":"随记","link":"/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"训练记录","slug":"训练记录","link":"/categories/%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/"},{"name":"算法总结","slug":"算法总结","link":"/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"}]}